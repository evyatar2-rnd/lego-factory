{"version":3,"sources":["webpack://lego-factory/webpack/universalModuleDefinition","webpack://lego-factory/webpack/bootstrap","webpack://lego-factory/webpack/runtime/define property getters","webpack://lego-factory/webpack/runtime/hasOwnProperty shorthand","webpack://lego-factory/webpack/runtime/make namespace object","webpack://lego-factory/./src/legoFactory/consts.js","webpack://lego-factory/./src/legoFactory/utils.js","webpack://lego-factory/./src/legoFactory/reconciler/defaultfunctions.js","webpack://lego-factory/./src/legoFactory/workInProgress.js","webpack://lego-factory/./src/legoFactory/render.js","webpack://lego-factory/./src/legoFactory/reconciler/index.js","webpack://lego-factory/./src/legoFactory/element.js","webpack://lego-factory/./src/legoFactory/hooks/hookState.js","webpack://lego-factory/./src/legoFactory/api/context/createContext.js","webpack://lego-factory/./src/legoFactory/hooks/useState.js","webpack://lego-factory/./src/legoFactory/hooks/useRef.js","webpack://lego-factory/./src/legoFactory/hooks/useEffect.js","webpack://lego-factory/./src/legoFactory/hooks/useMemo.js","webpack://lego-factory/./src/legoFactory/hooks/useCallback.js","webpack://lego-factory/./src/legoFactory/hooks/useContext.js","webpack://lego-factory/./src/legoFactory/webComponent/webcomponentContext.js","webpack://lego-factory/./src/legoFactory/hooks/useProp.js","webpack://lego-factory/./src/legoFactory/hooks/useHost.js","webpack://lego-factory/./src/legoFactory/hooks/useEvent.js","webpack://lego-factory/./src/legoFactory/hooks/useImperativeHandle.js","webpack://lego-factory/./src/legoFactory/webComponent/utils.js","webpack://lego-factory/./src/legoFactory/webComponent/createCustomElement.js","webpack://lego-factory/./src/legoFactory/webComponent/createWebcomponentHandler.js"],"names":["root","factory","exports","module","define","amd","a","i","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ELEMENT_TYPE","TEXT_ELEMENT","EMPTY_HOOK_STATE","isUndefined","isObject","isFunction","isArray","Array","isEvent","startsWith","isElement","$$type","isProperty","isNewProperty","prevProps","nextProps","isNewEvent","isFunctionComponent","fiber","type","Function","toEventName","propName","toLowerCase","substring","flat","parent","arr","flatten","keysMap","Map","indexInParent","length","index","rootNode","set","push","getType","getKey","getSiblingWithKey","childrenKeys","triggerFiberHandlers","handlerName","handlers","forEach","handler","registerFiberHandler","handlerIndex","findIndex","fiberHandler","splice","isSimilar","arr1","arr2","findNode","node","children","isInputNode","tagName","isValueProp","premiteveTypes","createInstance","vnode","document","createElement","createTextInstance","text","createTextNode","appendChild","child","insertBefore","beforeNode","updateInstance","oVnode","props","nVnode","eventName","removeEventListener","propType","includes","nodeType","hasAttribute","undefined","removeAttribute","style","entries","map","replace","str","join","setAttribute","addEventListener","removeChild","remove","treeRenderResolver","treeRender","currentFiber","currentHookIndex","resetTreeRender","Promise","res","resolveTreeRender","getTreeRender","reconciler","defaultCreateInstance","defaultCreateTextInstance","defaultAppendChild","defaultInsertBefore","defaultUpdateInstance","defaultRemoveChild","defaultRemove","Reconciler","vTrees","nVNode","oVNode","ref","current","appendChildInstance","parentNode","childNode","appendChildrenInstances","childrenNodes","nChild","oChild","parentElement","insertItemsBefore","nChilds","renderComponent","vNode","rendredChildren","componentType","renderChildren","parentVNode","nVChildren","oVChildren","nVChildrenLength","oVChildrenLength","maxChildrenLength","Math","max","childNodes","renderedNodes","renderNode","createNode","nodeValue","removeChildren","vChildren","removeNode","removeInstance","updateNode","state","hooks","nChildren","oChildren","parentNVNode","setWipFiber","context","created","render","willUpdate","willRemove","resetFiberHandlers","then","shouldUpdate","isRoot","getContainingNode","nodesToAdd","newNodes","oNode","oVNodeWithSameKey","vTree","containerNode","cb","nodes","unmountComponentAtNode","has","delete","createTextElement","getParent","this","didUpdate","element","childrenKeysMap","hasChildWithKey","renderedChildren","getFiber","initialValue","hookIndex","getHookState","newValue","shouldRender","setHookState","setTimeout","contextSymbol","Provider","getStateValue","setState","hookState","arg","deps","removeHandler","registerNoDepsHandlers","depsState","setDepsState","removeHandlerState","setRemoveHandlerState","registerDepsHandlers","calbk","calbkResaultState","setCalbkResaultState","resault","useMemo","ContextObject","createContext","webcomponentContext","useContext","WebcomponentContext","setProp","useState","getProp","useEffect","unregister","register","newProp","useRef","host","bubbles","isCustomEvent","useHost","detail","event","CustomEvent","Event","dispatchEvent","keys","setHandlers","ATTR_TYPES","Number","String","Boolean","Component","base","HTMLElement","shadowRoot","propTypes","attrs","filter","attr","isAttr","getAttrs","isProp","getProps","propsValues","reduce","values","constructor","super","webcomponentHandler","propValue","triggerHandlers","propHandler","createWebcomponentHandler","attachShadow","mode","attributeChangedCallback","name","oldValue","convertedValue","parseFloat","connectedCallback"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const ELEMENT_TYPE = Symbol(\"ELEMENT_TYPE\");\nexport const TEXT_ELEMENT = \"TEXT_ELEMENT\";\nexport const EMPTY_HOOK_STATE = Symbol(\"EMPTY_HOOK_STATE\");\nexport const TEXT_NODE_TYPE = 3;\nexport const INPUT_TAG_NAME = \"INPUT\";\n","import { ELEMENT_TYPE, TEXT_ELEMENT, INPUT_TAG_NAME } from \"./consts\";\n\nexport const isUndefined = (o) => typeof o === \"undefined\";\nexport const isNull = (o) => o === null;\nexport const isFalse = (o) => o === false;\nexport const isObject = (o) => typeof o === \"object\";\nexport const isFunction = (o) => typeof o === \"function\";\nexport const isArray = (o) => Array.isArray(o);\nexport const isString = (o) => typeof o === \"string\";\nexport const isEvent = (key) => key.startsWith(\"on\");\nexport const isElement = (o) => isObject(o) && o.$$type === ELEMENT_TYPE;\nexport const isTextElement = (o) => isElement(o) && o.type === TEXT_ELEMENT;\nexport const isProperty = (key) => key !== \"children\" && !isEvent(key);\nexport const isRefProperty = (key) => key === \"ref\";\nexport const isNewProperty = (prevProps, nextProps) => (key) =>\n  prevProps[key] !== nextProps[key];\nexport const isNewEvent = (prevProps, nextProps) => (key) =>\n  prevProps[key] !== nextProps[key];\nexport const isFunctionComponent = (fiber) =>\n  fiber && fiber.type instanceof Function;\nexport const toEventName = (propName) => propName.toLowerCase().substring(2);\n// The flat function is written like so, for better performance\nexport const flat = (\n  parent,\n  arr,\n  flatten = [],\n  keysMap = new Map(),\n  indexInParent = 0\n) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (isArray(arr[i])) {\n      flat(parent, arr[i], flatten, keysMap);\n      continue;\n    } else if (isObject(arr[i]) && arr[i].$$type === ELEMENT_TYPE) {\n      arr[i].index = indexInParent++;\n      arr[i].parent = parent;\n      arr[i].rootNode = parent.rootNode;\n\n      if (!isUndefined(arr[i].key)) {\n        keysMap.set(arr[i].key, arr[i]);\n      }\n    }\n    if (!isUndefined(arr[i]) && !isNull(arr[i]) && !isFalse(arr[i])) {\n      flatten.push(arr[i]);\n    }\n  }\n  return { flatten, keysMap };\n};\nexport const getComponentProps = (props) => {\n  return {\n    ...props,\n    children: props.children.length === 1 ? props.children[0] : props.children,\n  };\n};\nexport const isStylePropperty = (key) => key === \"style\";\nexport const toStrStyle = (style) =>\n  Object.entries(style)\n    .map(\n      ([key, value]) =>\n        `${key.replace(\n          /[A-Z][a-z]*/g,\n          (str) => \"-\" + str.toLowerCase()\n        )}: ${value}`\n    )\n    .join(\"; \");\nexport const getType = (fiber) => fiber.type;\nexport const hasSameType = (fiber, prevFiber) => {\n  if (!isUndefined(fiber) && isUndefined(prevFiber)) return false;\n  if (isUndefined(fiber) && !isUndefined(prevFiber)) return false;\n  if (getType(fiber) !== getType(prevFiber)) return false;\n\n  return true;\n};\nexport const hasKey = (fiber) =>\n  isUndefined(fiber) || isUndefined(fiber.key) ? false : true;\nexport const getKey = (fiber) => fiber.key;\nexport const hasSameKey = (fiber, prevFiber) => {\n  if (!isUndefined(fiber) && isUndefined(prevFiber)) return false;\n  if (isUndefined(fiber) && !isUndefined(prevFiber)) return false;\n  if (getKey(fiber) !== getKey(prevFiber)) return false;\n\n  return true;\n};\nexport const getSiblingWithKey = (fiber, key) => {\n  if (fiber && fiber.parent && fiber.parent.childrenKeys) {\n    return fiber.parent.childrenKeys.get(key);\n  }\n\n  return undefined;\n};\nexport const getChildrenByKey = (fiber, key) => {\n  if (fiber && fiber.childrenKeys) {\n    return fiber.childrenKeys.get(key);\n  }\n\n  return undefined;\n};\nexport const getPrevFiber = (fiber, prev) => {\n  const key = getKey(fiber || {});\n  const prevKey = getKey(prev || {});\n\n  if (isUndefined(fiber)) return prev;\n  //If keys are equal, event if both of them are undefined\n  if (key === prevKey) return prev;\n  if (isUndefined(key) && !isUndefined(prevKey)) return undefined;\n\n  return getSiblingWithKey(prev, key);\n};\nexport const triggerFiberHandlers = (fiber, handlerName) => {\n  if (fiber && fiber.handlers && isArray(fiber.handlers[handlerName])) {\n    fiber.handlers[handlerName].forEach((handler) => handler(fiber));\n  }\n};\nexport const registerFiberHandler = (fiber, handlerName, handler) => {\n  if (fiber && fiber.handlers && isArray(fiber.handlers[handlerName])) {\n    fiber.handlers[handlerName].push(handler);\n  }\n\n  return () => {\n    const handlerIndex = fiber.handlers[handlerName].findIndex(\n      (fiberHandler) => fiberHandler === handler\n    );\n\n    fiber.handlers[handlerName].splice(handlerIndex, 1);\n  };\n};\n\nexport const setFiberContext = (parent, fiber) => {\n  if (isUndefined(parent) || isUndefined(fiber)) return;\n\n  fiber.context = parent.context;\n};\nexport const resetFiberHandlers = (fiber) => {\n  if (!isElement(fiber)) return;\n\n  fiber.handlers = {\n    created: [],\n    render: [],\n    willUpdate: [],\n    willRemove: [],\n  };\n};\nexport const updateRef = (ref, node) => {\n  if (isObject(ref)) {\n    ref.current = node;\n  }\n  if (isFunction(ref)) {\n    ref(node);\n  }\n};\nexport const isSimilar = (arr1, arr2) => {\n  if (!isArray(arr1) || !isArray(arr2)) return false;\n\n  if (arr1.length !== arr2.length) return false;\n\n  for (var index = 0; index < arr1.length; index++) {\n    if (arr1[index] !== arr2[index]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const findNode = (fiber) => {\n  if (fiber.node) return fiber.node;\n\n  if (isArray(fiber.children)) {\n    for (let i = 0; i < fiber.children.length; i++) {\n      const node = findNode(fiber.children[i]);\n      if (!isUndefined(node)) return node;\n    }\n  }\n\n  return undefined;\n};\n\nexport const isInputNode = (node) => {\n  return node.tagName === INPUT_TAG_NAME;\n};\n\nexport const isValueProp = (prop) => prop === \"value\";\n","import { TEXT_NODE_TYPE } from \"../consts\";\nimport {\n  isUndefined,\n  isProperty,\n  isRefProperty,\n  isEvent,\n  isNewProperty,\n  isNewEvent,\n  toEventName,\n  isStylePropperty,\n  toStrStyle,\n  isInputNode,\n  isValueProp,\n} from \"../utils\";\n\nconst premiteveTypes = [\"string\", \"boolean\", \"number\"];\n\n/**\n * createInstance\n * @param {VNode} vnode - virtual dom node\n *\n * Create a DOM node based on the vnode param\n */\nexport const createInstance = (vnode) => {\n  const node = document.createElement(vnode.type);\n\n  return node;\n};\n\n/**\n * createTextInstance\n * @param {String} text\n *\n * Creates a DOM text node based on the text param\n */\nexport const createTextInstance = (text) => {\n  const node = document.createTextNode(text);\n\n  return node;\n};\n\n/**\n * appendChild\n * @param {DOMNode} parent\n * @param {DOMNode} child\n *\n * Appends the child DOMNode to the end of the parent DOMNode\n */\nexport const appendChild = (parent, child) => {\n  parent.appendChild(child);\n};\n\n/**\n * insertBefore\n * @param {DOMNode} parent\n * @param {DOMNode} child\n * @param {DOMNode} beforeNode\n *\n * Inserts the child DOMNode into the parent DOMNode before the reference beforeNode\n */\nexport const insertBefore = (parent, child, beforeNode) => {\n  parent.insertBefore(child, beforeNode);\n};\n\n/**\n * updateInstance\n * @param {DOMnode} node\n * @param {VNode} oVnode\n * @param {VNode} nVnode\n *\n * Updates the node DOMNode attirbutes properties and events based on the difference between oVnode VNode and nVnode VNode\n */\nexport const updateInstance = (\n  node,\n  oVnode = { props: {} },\n  nVnode = { props: {} }\n) => {\n  // Remove old properties and events\n  for (const prop in oVnode.props) {\n    if (isEvent(prop)) {\n      if (\n        !isUndefined(nVnode.props[prop]) &&\n        !isNewEvent(oVnode.props, nVnode.props)(prop)\n      )\n        continue;\n\n      const eventName = toEventName(prop);\n      node.removeEventListener(eventName, oVnode.props[prop]);\n    } else if (isProperty(prop)) {\n      if (\n        !isUndefined(nVnode.props[prop]) &&\n        !isNewProperty(oVnode.props, nVnode.props)(prop)\n      ) {\n        continue;\n      }\n\n      const propType = typeof nVnode.props[prop];\n      if (\n        premiteveTypes.includes(propType) &&\n        node.nodeType !== TEXT_NODE_TYPE &&\n        !(isInputNode(node) && isValueProp(prop))\n      ) {\n        node.removeAttribute(prop);\n      } else {\n        if (node.hasAttribute && node.hasAttribute(prop)) {\n          delete node[prop];\n        } else {\n          node[prop] = undefined;\n        }\n      }\n    }\n  }\n\n  // Set new properties and events\n  for (const prop in nVnode.props) {\n    if (\n      isNewProperty(oVnode.props, nVnode.props)(prop) &&\n      isProperty(prop) &&\n      !isRefProperty(prop)\n    ) {\n      if (isStylePropperty(prop)) {\n        node[prop] = toStrStyle(nVnode.props[prop]);\n      } else {\n        const propType = typeof nVnode.props[prop];\n        if (\n          premiteveTypes.includes(propType) &&\n          node.nodeType !== TEXT_NODE_TYPE &&\n          !(isInputNode(node) && isValueProp(prop))\n        ) {\n          node.setAttribute(prop, nVnode.props[prop]);\n        } else {\n          node[prop] = nVnode.props[prop];\n        }\n      }\n    }\n\n    if (isEvent(prop) && isNewProperty(oVnode.props, nVnode.props)(prop)) {\n      const eventName = toEventName(prop);\n\n      node.addEventListener(eventName, nVnode.props[prop]);\n    }\n  }\n\n  return node;\n};\n\n/**\n * removeChild\n * @param {DOMNode} parent\n * @param {DOMNode} child\n *\n * Removes the child DOMnode from the parent DOMNode\n */\nexport const removeChild = (parent, child) => {\n  parent.removeChild(child);\n};\n\n/**\n * remove\n * @param {DOMNode} node\n *\n * Removes the node DOMNode\n */\nexport const remove = (node) => {\n  node.remove();\n};\n","import { EMPTY_HOOK_STATE } from \"./consts\";\nimport { isFunction } from \"./utils\";\n\nlet treeRenderResolver = undefined;\nlet treeRender = undefined;\nlet currentFiber = undefined;\nlet currentHookIndex = 0;\n\nexport const getWipHookIndex = () => currentHookIndex;\nexport const resetHookIndex = () => {\n  currentHookIndex = -1;\n};\nexport const gotoLastHookIndex = (fiber) => {\n  currentHookIndex = fiber.hooks.length;\n};\nexport const incHook = () => {\n  currentHookIndex = currentHookIndex + 1;\n  if (currentFiber.hooks.length < currentHookIndex) {\n    currentFiber.hooks.push(EMPTY_HOOK_STATE);\n  }\n  return currentHookIndex;\n};\n\nexport const setWipFiber = (fiber) => {\n  currentFiber = fiber;\n  resetHookIndex();\n};\nexport const getWipFiber = () => currentFiber;\n\nexport const resetTreeRender = () => {\n  treeRender = new Promise((res) => {\n    treeRenderResolver = res;\n  });\n};\n\nexport const resolveTreeRender = () => {\n  if (isFunction(treeRenderResolver)) treeRenderResolver();\n};\n\nexport const getTreeRender = () => treeRender;\n","import Reconciler from \"./reconciler/index\";\nimport {\n  isUndefined,\n  isFunction,\n  isTextElement,\n  isFunctionComponent,\n  getType,\n  getComponentProps,\n  setFiberContext,\n  resetFiberHandlers,\n  isArray,\n  triggerFiberHandlers,\n  getKey,\n  getSiblingWithKey,\n  findNode,\n} from \"./utils\";\nimport {\n  setWipFiber,\n  resetTreeRender,\n  getTreeRender,\n  resolveTreeRender,\n} from \"./workInProgress\";\n\nconst reconciler = Reconciler();\n\n/**\n * Situtations that might happen\n *                        oVNode | nVNode | equal | sameKey | sameType\n * 1. Create                 -   |    +   |       |         |\n * 2. Update                 +   |    +   |   -   |    -    |    +\n * 3. Update                 +   |    +   |   -   |    +    |    +\n * 4. Replace                +   |    +   |   -   |    +    |    -\n * 5. Replace                +   |    +   |   -   |    -    |\n * 6. Remove                 +   |    -   |       |         |\n * 7. Remove                 +   |    +   |   -   |    -    |\n * 8. Memoized               +   |    +   |   +   |         |\n */\n\nconst vTrees = new Map();\n\nconst createInstance = (vNode) => {\n  const node = isTextElement(vNode)\n    ? reconciler.createTextInstance(vNode.props.nodeValue)\n    : reconciler.createInstance(vNode);\n\n  reconciler.updateInstance(node, undefined, vNode);\n\n  return node;\n};\n\nconst updateInstance = (nVNode, oVNode) => {\n  if (!isUndefined(oVNode)) {\n    nVNode.node = oVNode.node;\n  }\n\n  reconciler.updateInstance(nVNode.node, oVNode, nVNode);\n\n  if (!isUndefined(nVNode.ref)) {\n    if (isFunction(nVNode.ref)) {\n      nVNode.ref(nVNode.node);\n    } else {\n      nVNode.ref.current = nVNode.node;\n    }\n  }\n\n  return nVNode.node;\n};\n\nconst removeInstance = (vNode) => {\n  reconciler.remove(vNode);\n};\n\nconst appendChildInstance = (parentNode, childNode) => {\n  if (isUndefined(childNode)) return;\n\n  reconciler.appendChild(parentNode, childNode);\n};\n\nconst appendChildrenInstances = (parentNode, childrenNodes) => {\n  for (let i = 0; i < childrenNodes.length; i++) {\n    appendChildInstance(parentNode, childrenNodes[i]);\n  }\n};\n\nconst insertBefore = (nChild, oChild) => {\n  reconciler.insertBefore(oChild.parentElement, nChild, oChild);\n};\n\nconst insertItemsBefore = (nChilds, oChild) => {\n  for (let i = 0; i < nChilds.length; i++) {\n    reconciler.insertBefore(oChild.parentElement, nChilds[i], oChild);\n  }\n};\n\nconst renderComponent = (vNode) => {\n  const componentType = getType(vNode);\n  const rendredChildren = componentType(getComponentProps(vNode.props));\n\n  return isArray(rendredChildren) ? rendredChildren : [rendredChildren];\n};\n\nconst renderChildren = (parentVNode, nVChildren = [], oVChildren = []) => {\n  const nVChildrenLength = nVChildren.length;\n  const oVChildrenLength = oVChildren.length;\n  const maxChildrenLength = Math.max(nVChildrenLength, oVChildrenLength);\n\n  const childNodes = [];\n\n  for (let i = 0; i < maxChildrenLength; i++) {\n    const nChild = i < nVChildrenLength ? nVChildren[i] : undefined;\n    const oChild = i < oVChildrenLength ? oVChildren[i] : undefined;\n    const renderedNodes = renderNode(parentVNode, nChild, oChild);\n\n    if (isArray(renderedNodes)) {\n      childNodes.push(...renderedNodes);\n    } else {\n      childNodes.push(renderedNodes);\n    }\n  }\n\n  return childNodes;\n};\n\nconst createNode = (nVNode) => {\n  if (isFunctionComponent(nVNode)) {\n    nVNode.children = renderComponent(nVNode);\n  } else {\n    nVNode.node = createInstance(nVNode);\n    updateInstance(nVNode, undefined);\n  }\n  const children = isFunctionComponent(nVNode)\n    ? nVNode.children\n    : nVNode.props.children;\n  const childNodes = renderChildren(nVNode, children, undefined);\n\n  if (isUndefined(nVNode.node)) {\n    return childNodes;\n  }\n\n  appendChildrenInstances(nVNode.node, childNodes);\n  return nVNode.node;\n};\n\nconst removeChildren = (vChildren) => {\n  for (let i = 0; i < vChildren.length; i++) {\n    removeNode(vChildren[i]);\n  }\n};\n\nconst removeNode = (vNode) => {\n  if (isFunctionComponent(vNode)) {\n    removeChildren(vNode.children);\n  } else {\n    removeChildren(vNode.props.children);\n    removeInstance(vNode.node);\n  }\n};\n\nconst updateNode = (nVNode, oVNode) => {\n  nVNode.node = oVNode.node;\n  nVNode.state = oVNode.state;\n  nVNode.hooks = oVNode.hooks;\n\n  if (!isFunctionComponent(nVNode)) {\n    updateInstance(nVNode, oVNode);\n  }\n\n  const nChildren = isFunctionComponent(nVNode)\n    ? renderComponent(nVNode)\n    : nVNode.props.children;\n  const oChildren = isFunctionComponent(oVNode)\n    ? oVNode.children\n    : oVNode.props.children;\n  const childNodes = renderChildren(nVNode, nChildren, oChildren);\n\n  nVNode.children = nChildren;\n\n  if (isUndefined(nVNode.node)) {\n    return childNodes;\n  }\n\n  appendChildrenInstances(nVNode.node, childNodes);\n\n  return nVNode.node;\n};\n\nconst renderNode = (parentNVNode, nVNode, oVNode) => {\n  if (isUndefined(nVNode) && isUndefined(oVNode)) {\n    return;\n  }\n\n  if (isUndefined(nVNode)) {\n    removeNode(oVNode);\n    return;\n  }\n\n  nVNode.parent = parentNVNode;\n  setWipFiber(nVNode);\n  setFiberContext(parentNVNode, nVNode);\n  resetFiberHandlers(nVNode);\n\n  if (!isUndefined(nVNode) && isUndefined(oVNode)) {\n    triggerFiberHandlers(nVNode, \"created\");\n    getTreeRender().then(() => {\n      triggerFiberHandlers(nVNode, \"render\");\n    });\n    return createNode(nVNode);\n  }\n\n  if (nVNode === oVNode) {\n    if (nVNode.shouldUpdate || nVNode.parent.shouldUpdate) {\n      triggerFiberHandlers(oVNode, \"willUpdate\");\n      getTreeRender().then(() => {\n        triggerFiberHandlers(nVNode, \"render\");\n      });\n\n      const parentNode = nVNode.isRoot\n        ? nVNode.getContainingNode()\n        : parentNVNode.getContainingNode();\n      const nodesToAdd = updateNode(nVNode, oVNode);\n\n      appendChildrenInstances(parentNode, nodesToAdd);\n\n      nVNode.shouldUpdate = false;\n    }\n\n    return;\n  }\n\n  if (getType(nVNode) === getType(oVNode)) {\n    if (getKey(nVNode) === getKey(oVNode)) {\n      triggerFiberHandlers(oVNode, \"willUpdate\");\n      getTreeRender().then(() => {\n        triggerFiberHandlers(nVNode, \"render\");\n      });\n\n      updateNode(nVNode, oVNode);\n\n      return;\n    }\n  }\n\n  // replace\n  if (getKey(nVNode) === getKey(oVNode) || isUndefined(getKey(nVNode))) {\n    const newNodes = createNode(nVNode);\n    const oNode = findNode(oVNode);\n\n    if (isUndefined(oNode)) {\n      return newNodes;\n    }\n\n    if (isArray(newNodes)) {\n      insertItemsBefore(newNodes, oNode);\n    } else {\n      insertBefore(newNodes, oNode);\n    }\n\n    triggerFiberHandlers(nVNode, \"created\");\n    getTreeRender().then(() => {\n      triggerFiberHandlers(nVNode, \"render\");\n    });\n\n    if (\n      isUndefined(getKey(oVNode)) ||\n      isUndefined(getSiblingWithKey(nVNode, getKey(oVNode)))\n    ) {\n      getTreeRender().then(() => {\n        triggerFiberHandlers(oVNode, \"willRemove\");\n      });\n      removeNode(oVNode);\n    }\n    return;\n  }\n\n  //if nVNode has old child with same key then move that child before oVNode\n  //else create new child before oVNode\n  const oVNodeWithSameKey = getSiblingWithKey(oVNode);\n  if (!isUndefined(oVNodeWithSameKey)) {\n    triggerFiberHandlers(oVNodeWithSameKey, \"willUpdate\");\n  }\n  if (isUndefined(oVNodeWithSameKey)) {\n    triggerFiberHandlers(nVNode, \"created\");\n    getTreeRender().then(() => {\n      triggerFiberHandlers(nVNode, \"render\");\n    });\n  }\n\n  const newNodes = !isUndefined(oVNodeWithSameKey)\n    ? updateNode(nVNode, oVNodeWithSameKey)\n    : createNode(nVNode);\n  const oNode = findNode(oVNode);\n\n  if (isUndefined(oNode)) {\n    return newNodes;\n  }\n\n  if (isArray(newNodes)) {\n    insertItemsBefore(newNodes, oNode);\n  } else {\n    insertBefore(newNodes, oNode);\n  }\n\n  //if oVNode as no new child with same key then remove oVNode\n  if (\n    isUndefined(getKey(oVNode)) ||\n    isUndefined(getSiblingWithKey(nVNode, getKey(oVNode)))\n  ) {\n    getTreeRender().then(() => {\n      triggerFiberHandlers(oVNode, \"willRemove\");\n    });\n    removeNode(oVNode);\n  }\n};\n\nexport const reRenderNode = (vNode) => {\n  resetTreeRender();\n\n  vNode.shouldUpdate = true;\n  if (vNode.isRoot) {\n    render(vNode, vNode.rootNode);\n  } else {\n    renderNode(vNode.parent, vNode, vNode);\n  }\n\n  resolveTreeRender();\n  resetTreeRender();\n};\n\n/**\n * render\n * @param {VNode} vtree\n * @param {DOMNode} containerNode\n *\n * Renders the virtual tree of typ VNode to the containerNode\n */\nconst render = (vTree, containerNode, cb) => {\n  resetTreeRender();\n\n  vTree.isRoot = true;\n  vTree.rootNode = containerNode;\n\n  const nodes = renderNode(\n    undefined,\n    vTree,\n    vTrees.get(containerNode),\n    containerNode\n  );\n\n  if (isArray(nodes)) {\n    appendChildrenInstances(containerNode, nodes);\n  } else {\n    appendChildInstance(containerNode, nodes);\n  }\n\n  vTrees.set(containerNode, vTree);\n\n  resolveTreeRender();\n  resetTreeRender();\n\n  if (isFunction(cb)) {\n    cb();\n  }\n};\n\n/**\n * unmountComponentAtNode\n * @param {DOMNode} containerNode\n *\n * If there is a vTree belongs to the containerNode it is unmounted and removed from the vTrees\n */\nexport const unmountComponentAtNode = (containerNode) => {\n  if (!vTrees.has(containerNode)) return;\n\n  vTrees.delete(containerNode);\n};\n\nexport default render;\n","import {\n  createInstance as defaultCreateInstance,\n  createTextInstance as defaultCreateTextInstance,\n  appendChild as defaultAppendChild,\n  insertBefore as defaultInsertBefore,\n  updateInstance as defaultUpdateInstance,\n  removeChild as defaultRemoveChild,\n  remove as defaultRemove,\n} from \"./defaultfunctions\";\n\nconst Reconciler = ({\n  createInstance = defaultCreateInstance,\n  createTextInstance = defaultCreateTextInstance,\n  appendChild = defaultAppendChild,\n  insertBefore = defaultInsertBefore,\n  updateInstance = defaultUpdateInstance,\n  removeChild = defaultRemoveChild,\n  remove = defaultRemove,\n} = {}) => {\n  return {\n    createInstance,\n    createTextInstance,\n    appendChild,\n    insertBefore,\n    updateInstance,\n    removeChild,\n    remove,\n  };\n};\n\nexport default Reconciler;\n","import { ELEMENT_TYPE, TEXT_ELEMENT } from \"./consts\";\nimport { isUndefined, isObject, isFunction, flat } from \"./utils\";\n\nconst createTextElement = (parent, text) => {\n  return {\n    $$type: ELEMENT_TYPE,\n    type: TEXT_ELEMENT,\n    isRoot: false,\n    rootNode: undefined,\n    ref: undefined,\n    key: undefined,\n    childrenKeys: undefined,\n    parent: undefined,\n    getParent: function () {\n      return this.parent;\n    },\n    getContainingNode: function () {\n      if (this.isRoot) return this.rootNode;\n\n      let parent = this.parent;\n\n      while (\n        !isUndefined(parent) &&\n        isUndefined(parent.node) &&\n        !parent.isRoot\n      ) {\n        parent = parent.parent;\n      }\n\n      return parent.node || parent.rootNode;\n    },\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n    hooks: [],\n    context: undefined,\n    handlers: {\n      created: [],\n      render: [],\n      willUpdate: [],\n      didUpdate: [],\n      willRemove: [],\n    },\n  };\n};\n\nexport const createElement = (type, props, ...children) => {\n  const element = {\n    $$type: ELEMENT_TYPE,\n    type,\n    isRoot: false,\n    rootNode: undefined,\n    ref: props ? props.ref : undefined,\n    key: props ? props.key : undefined,\n    parent: undefined,\n    getParent: function () {\n      return this.parent;\n    },\n    getContainingNode: function () {\n      if (this.isRoot) return this.rootNode;\n\n      let parent = this.parent;\n\n      while (\n        !isUndefined(parent) &&\n        isUndefined(parent.node) &&\n        !parent.isRoot\n      ) {\n        parent = parent.parent;\n      }\n\n      return parent.node || parent.rootNode;\n    },\n    props: {\n      ...props,\n      children: [],\n    },\n    children: [],\n    childrenKeysMap: undefined,\n    hasChildWithKey: (key) => {\n      if (isUndefined(this.childrenKeysMap)) return false;\n\n      return this.childrenKeysMap.has(key);\n    },\n    renderedChildren: [],\n    hooks: [],\n    context: undefined,\n    handlers: {\n      created: [],\n      render: [],\n      willUpdate: [],\n      didUpdate: [],\n      willRemove: [],\n    },\n  };\n\n  const { flatten, keysMap } = flat(element, children);\n\n  element.props.children = flatten.map((child) =>\n    isObject(child) || isFunction(child)\n      ? child\n      : createTextElement(element, child)\n  );\n  element.childrenKeysMap = keysMap;\n\n  return element;\n};\n","import { EMPTY_HOOK_STATE } from \"../consts\";\nimport { getWipFiber, incHook } from \"../workInProgress\";\n// import { renderFiber } from \"../vdom\";\nimport { reRenderNode } from \"../render\";\n\nexport const getFiber = getWipFiber;\n\nexport const getHookIndex = incHook;\n\nexport const getHookState = (fiber, hookIndex, initialValue) => {\n  const hooks = fiber.hooks;\n\n  if (hooks.length < hookIndex + 1) {\n    hooks.push(initialValue);\n  }\n\n  if (hooks[hookIndex] === EMPTY_HOOK_STATE) {\n    hooks[hookIndex] = initialValue;\n  }\n\n  return hooks[hookIndex];\n};\n\nexport const setHookState = (fiber, hookIndex, value) => {\n  fiber.hooks[hookIndex] = value;\n};\n\nconst hookState = (fiber, initialValue) => {\n  const hookIndex = getHookIndex();\n  const hookState = getHookState(fiber, hookIndex, initialValue);\n\n  return [\n    hookState,\n    (newValue, shouldRender = false) => {\n      setHookState(fiber, hookIndex, newValue);\n\n      if (shouldRender) {\n        setTimeout(() => {\n          // renderFiber(fiber);\n          reRenderNode(fiber);\n        }, 0);\n      }\n    },\n  ];\n};\n\nexport default hookState;\n","import { isUndefined } from \"../../utils\";\nimport { getFiber } from \"../../hooks/hookState\";\n\nconst createContext = (initialValue) => {\n  const contextSymbol = Symbol();\n\n  return {\n    Provider: ({ value, children }) => {\n      const fiber = getFiber();\n\n      if (isUndefined(fiber.context)) {\n        fiber.context = new Map();\n        fiber.context.set(\n          contextSymbol,\n          isUndefined(value) ? initialValue : value\n        );\n      }\n\n      if (!isUndefined(value) && value !== fiber.context.get(contextSymbol)) {\n        fiber.context.set(contextSymbol, value);\n      }\n\n      return children;\n    },\n\n    getStateValue: () => {\n      const fiber = getFiber();\n\n      if (isUndefined(fiber.context)) {\n        fiber.context = new Map();\n      }\n      if (isUndefined(fiber.context.get(contextSymbol))) {\n        fiber.context.set(contextSymbol, initialValue);\n      }\n\n      return fiber.context.get(contextSymbol);\n    },\n  };\n};\n\nexport default createContext;\n","import { isFunction } from \"../utils\";\nimport hookState, { getFiber } from \"./hookState\";\n\nconst useState = (initialValue) => {\n  const fiber = getFiber();\n  const [state, setState] = hookState(fiber, initialValue);\n\n  return [\n    state,\n    (arg) => {\n      setState(isFunction(arg) ? arg(state) : arg, true);\n    },\n  ];\n};\n\nexport default useState;\n","import hookState, { getFiber } from \"./hookState\";\n\nconst useRef = (initialValue) => {\n  const fiber = getFiber();\n  const [ref] = hookState(fiber, { current: initialValue });\n  return ref;\n};\n\nexport default useRef;\n","import {\n  isUndefined,\n  isArray,\n  isFunction,\n  registerFiberHandler,\n  isSimilar,\n} from \"../utils\";\nimport hookState, { getFiber } from \"./hookState\";\n\nconst registerNoDepsHandlers = (fiber, handler) => {\n  registerFiberHandler(fiber, \"render\", () => {\n    const removeHandler = handler();\n\n    registerFiberHandler(fiber, \"willUpdate\", removeHandler);\n    registerFiberHandler(fiber, \"willRemove\", removeHandler);\n  });\n};\n\nconst registerDepsHandlers = (fiber, handler, deps) => {\n  const [depsState, setDepsState] = hookState(fiber, undefined);\n  const [removeHandlerState, setRemoveHandlerState] = hookState(\n    fiber,\n    () => {}\n  );\n\n  registerFiberHandler(fiber, \"render\", () => {\n    if (!isSimilar(deps, depsState)) {\n      if (isFunction(removeHandlerState)) {\n        removeHandlerState();\n      }\n      setDepsState(deps);\n\n      const removeHandler = handler();\n\n      setRemoveHandlerState(removeHandler);\n      registerFiberHandler(fiber, \"willRemove\", removeHandler);\n    }\n  });\n};\n\nconst useEffect = (handler, deps) => {\n  const fiber = getFiber();\n\n  if (isUndefined(deps)) {\n    registerNoDepsHandlers(fiber, handler);\n  }\n\n  if (isArray(deps)) {\n    registerDepsHandlers(fiber, handler, deps);\n  }\n};\n\nexport default useEffect;\n","import { EMPTY_HOOK_STATE } from \"../consts\";\nimport { isSimilar } from \"../utils\";\nimport hookState, { getFiber } from \"./hookState\";\n\nconst useMemo = (calbk, deps) => {\n  const fiber = getFiber();\n  const [depsState, setDepsState] = hookState(fiber, EMPTY_HOOK_STATE);\n  const [calbkResaultState, setCalbkResaultState] = hookState(\n    fiber,\n    EMPTY_HOOK_STATE\n  );\n\n  if (depsState === EMPTY_HOOK_STATE) {\n    const resault = calbk();\n    setDepsState(deps);\n    setCalbkResaultState(resault);\n\n    return resault;\n  }\n\n  if (isSimilar(deps, depsState)) {\n    return calbkResaultState;\n  } else {\n    const resault = calbk();\n    setDepsState(deps);\n    setCalbkResaultState(resault);\n\n    return resault;\n  }\n};\n\nexport default useMemo;\n","import useMemo from \"./useMemo\";\n\nconst useCallback = (calbk, deps) => useMemo(() => calbk, deps);\n\nexport default useCallback;\n","const useContext = (ContextObject) => {\n  return ContextObject.getStateValue();\n};\n\nexport default useContext;\n","import { createContext } from \"../index\";\n\nconst WebcomponentContext = createContext();\n\nexport default WebcomponentContext;\n","import useContext from \"./useContext\";\nimport useState from \"./useState\";\nimport useEffect from \"./useEffect\";\nimport WebcomponentContext from \"../webComponent/webcomponentContext\";\n\nconst useProp = (propName) => {\n  const webcomponentContext = useContext(WebcomponentContext);\n  const [prop, setProp] = useState(\n    WebcomponentContext.getStateValue().getProp(propName)\n  );\n\n  useEffect(() => {\n    const unregister = webcomponentContext.register(propName, (newProp) => {\n      setProp(newProp);\n    });\n    return () => {\n      unregister();\n    };\n  }, [propName, webcomponentContext]);\n\n  return prop;\n};\n\nexport default useProp;\n","import useContext from \"./useContext\";\nimport useRef from \"./useRef\";\nimport WebcomponentContext from \"../webComponent/webcomponentContext\";\n\nconst useHost = () => {\n  const webcomponentContext = useContext(WebcomponentContext);\n  const refHost = useRef(WebcomponentContext.getStateValue().host);\n\n  return refHost;\n};\n\nexport default useHost;\n","import useHost from \"./useHost\";\n\nconst useEvent = (eventName, { bubbles, isCustomEvent = true } = {}) => {\n  const host = useHost();\n\n  return (detail) => {\n    const event = isCustomEvent\n      ? new CustomEvent(eventName, { detail })\n      : new Event(eventName, detail);\n\n    host.current.dispatchEvent(event);\n  };\n};\n\nexport default useEvent;\n","import { EMPTY_HOOK_STATE } from \"../consts\";\nimport { isUndefined, isSimilar, isFunction } from \"../utils\";\nimport hookState, { getFiber } from \"./hookState\";\n\nconst setHandlers = (node, handlers) => {\n  Object.keys(handlers).forEach((handlerName) => {\n    node[handlerName] = handlers[handlerName];\n  });\n};\n\nconst useImperativeHandle = (ref, handlers, deps) => {\n  const fiber = getFiber();\n  const [depsState, setDepsState] = hookState(fiber, EMPTY_HOOK_STATE);\n\n  if (depsState === EMPTY_HOOK_STATE || !isSimilar(deps, depsState)) {\n    setDepsState(deps);\n\n    if (isUndefined(ref) || isUndefined(ref.current) || !isFunction(handlers))\n      return;\n\n    setHandlers(ref.current, handlers());\n\n    return;\n  }\n};\n\nexport default useImperativeHandle;\n","export const ATTR_TYPES = [Number, String, Boolean];\nexport const isAttr = (type) => ATTR_TYPES.includes(type);\nexport const isProp = (type) => !ATTR_TYPES.includes(type);\nexport const getAttrs = (propTypes) =>\n  Object.keys(propTypes).filter((attr) => isAttr(propTypes[attr].type));\nexport const getProps = (propTypes) =>\n  Object.keys(propTypes).filter((attr) => isProp(propTypes[attr].type));\n","/** @jsxRuntime classic */\n/** @jsx createElement */\n\nimport { getAttrs, getProps } from \"./utils\";\nimport { render, createElement } from \"../index\";\nimport WebcomponentContext from \"./webcomponentContext\";\nimport createWebcomponentHandler from \"./createWebcomponentHandler\";\n\nconst createShadowRoow = (node) => {\n  return node.attachShadow({ mode: \"open\" });\n};\n\nconst createCustomElement = (\n  Component,\n  { base = HTMLElement, shadowRoot = false } = {}\n) => {\n  const propTypes = Component.propTypes || {}; // eslint-disable-line react/forbid-foreign-prop-types\n\n  const attrs = getAttrs(propTypes);\n\n  const props = getProps(propTypes);\n\n  const propsValues = Object.keys(propTypes).reduce((values, prop) => {\n    return {\n      ...values,\n      [prop]: propTypes[prop].initialValue,\n    };\n  }, {});\n\n  class Element extends base {\n    static get observedAttributes() {\n      return attrs;\n    }\n\n    constructor() {\n      super();\n\n      this.webcomponentHandler = createWebcomponentHandler(this);\n\n      props.forEach((prop) => {\n        Object.defineProperty(this, prop, {\n          set(newValue) {\n            propsValues[prop] = newValue;\n            this.webcomponentHandler.setProp(prop, newValue);\n          },\n          get() {\n            return propsValues[prop];\n          },\n        });\n      });\n\n      if (shadowRoot) {\n        createShadowRoow(this);\n      }\n\n      Object.keys(propTypes).forEach((prop) => {\n        this.webcomponentHandler.setProp(prop, propsValues[prop]);\n      });\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      const convertedValue =\n        propTypes[name].type === Boolean\n          ? newValue === \"\"\n            ? true\n            : newValue === \"true\"\n            ? true\n            : false\n          : propTypes[name].type === Number\n          ? parseFloat(newValue)\n          : newValue;\n      this.webcomponentHandler.setProp(name, convertedValue);\n    }\n\n    connectedCallback() {\n      render(\n        <WebcomponentContext.Provider value={this.webcomponentHandler}>\n          <Component />\n        </WebcomponentContext.Provider>,\n        this.shadowRoot ? this.shadowRoot : this\n      );\n    }\n  }\n\n  return Element;\n};\n\nexport default createCustomElement;\n","const triggerHandlers = (handlers, propValue) => {\n  for (let i = 0; i < handlers.length; i++) {\n    handlers[i](propValue);\n  }\n};\n\nconst createWebcomponentHandler = (host) => {\n  const handlers = {};\n  const state = {};\n\n  return {\n    host,\n    setProp: (propName, propValue) => {\n      if (state[propName] === propValue) return;\n\n      state[propName] = propValue;\n      handlers[propName] = handlers[propName] || [];\n      triggerHandlers(handlers[propName], propValue);\n    },\n    getProp: (propName) => state[propName],\n    register: (propName, handler) => {\n      handlers[propName] = handlers[propName] || [];\n      handlers[propName].push(handler);\n\n      return () => {\n        handlers[propName] = handlers[propName].filter(\n          (propHandler) => propHandler !== handler\n        );\n      };\n    },\n  };\n};\n\nexport default createWebcomponentHandler;\n"],"sourceRoot":""}